#define __AVR_ATmega328P__     //нужный микроконтролер
#define F_CPU 1000000UL         //определённая частота для правильной работы (количиство тактов /\ частота)
#include <util/delay.h>
#include <avr/io.h>


int AL,ah; //переменные для считывание старшего и младшего разряда 
unsigned char flag = 1; //переменная для смены каналов
unsigned char ch = 1; //смена режима работы

void shim1(){ //первый шим
    DDRB |= (1 << PB3);
    TCCR2A |= (1 << WGM20) | (1 << WGM21) | (1 << COM2A1); 
    TCCR2B |= (1 << CS21); 
}

void shim2(){ //второй шим
    TCCR0A |= (1 << WGM00) | (1 << WGM01) | (1 << COM0A1); 
    TCCR0B |= (1 << CS01); 
}

void ADC_init(){ //сам ADC
    ADCSRA |= (1 << ADEN) | (1 << ADSC) | (1 << ADPS2);
    ADMUX = (1 << ADLAR);
}

int main(){
shim1(); // включение 1-2 Шима, ADC
shim2();
ADC_init();
DDRD = 0b01000011; // включаем шим и лампы с кнопкой
PORTD = 0b00100000; //подтягивает резистор
while(1){ 
    if((PIND & (1 << PD5)) == 0){
        switch(ch){ //читаем кнопку
            case 0:ch = 1;break;
            case 1:ch = 0;break;
        }
        _delay_ms(10);
    }
    if(ch){
        if(((~ADCSRA)&(1 << ADSC)) == (1 << ADSC)){ // гига условие для проверки нуля в ADSC
            AL = ADCL; //считаем младший разряд 
            ah = ADCH / 1.1; //считаем старший разряд
            PORTD = 0b00100010; //включаем лампочку вторую
                if(flag == 1){ //первый сервопривод 
                ADMUX &= 0b11110000;
                ADMUX |= (1 << MUX0) | (1 << MUX1) | (0 << MUX2); //меняем канал ADC
                OCR2A = ah; //считываем старший разряд
                flag = 0; // после работы переворачиваем значение для переключения сервы
                }else if(flag == 0){ //после включается вторая серва
                ADMUX &= 0b11110000;
                ADMUX |= (0 << MUX0) | (0 << MUX1) | (1 << MUX2); // переключение канала ADC
                OCR0A = ah; //считываем старшую пару
                flag = 1; // переворачиваем значение для переключения сервы
                }
            _delay_ms(1);
            ADCSRA |= (1 << ADSC); //заносим единицу в преобразователь повторно 
            _delay_ms(10);
        }   
    }else{
        PORTD = 0b00100001; //включаем первую лампочку выключаем вторую
        _delay_ms(250);
        OCR2A = 128;
        OCR0A = 128;
    }
}
return 0;
}